---
order: 0.2
title: data structure
description: 자료구조 - 리스트
summary:
keywords:
- data
- data structure
- list
- array
- 리스트
- 배열
tags:
- data
created_time: 2024-09-20 05:41
modified_time: 2024-11-08 17:51
---

# List
= 선형 리스트, 순서 리스트  
: 데이터를 순서대로 저장하는 자료구조  
: 구현 방식에 따라 순차 리스트와 연결 리스트로 분류됨  

**종류**
- [순차 리스트](#sequential-list)
  - [정적 배열](#array)
  - [동적 배열](#dynamic-array)
- [연결 리스트](#linked-list)
  - [단일 연결 리스트](#singly-linked-list)
  - [이중 연결 리스트](#doubly-linked-list)
  - [원형 연결 리스트](#circular-linked-list)

**특징**

특징 | 순차 리스트 | 연결 리스트
---|---
메모리 크기 | 고정 크기 (동적 배열은 동적) | 동적 크기
메모리 할당 | 메모리 연속 할당 | 메모리 분산 할당
메모리 접근 | 인덱스를 통해 직접 접근 | 순차적 접근 
삽입 및 삭제 | 삽입과 삭제시 비용 증가 | 삽입과 삭제에 효율적


**선택 기준**

자료구조 | 기준
---|---
순차 리스트 | - 데이터 크기가 예측 가능함<br>- 데이터 검색이 빈번함
연결 리스트 | - 데이터 크기가 가변적임<br>- 데이터 삽입/삭제가 빈번함<br>- 메모리 사용 최적화 필요



## Sequential List
: 데이터의 논리적 순서와 물리적 순서가 일치하는 자료구조  
: 인덱스를 통해 메모리에 직접 접근이 가능함  

**시간 복잡도**
- 접근 : O(1)
- 조회 : O(n)
- 삽입 : O(n)
- 삭제 : O(n)


**구현체**
- [정적 배열](#array)
- [동적 배열](#dynamic-array)

**특징**

특징 | 정적 배열 | 동적 배열
---|---
메모리 크기 | 고정 크기 | 가변 크기 (자동 확장)
메모리 할당 | 연속 메모리 할당 | 연속 메모리 할당 (재할당 발생)
메모리 접근 | 인덱스로 직접 접근 | 인덱스로 직접 접근 
효율성 | 삽입/삭제 비효율 | 삽입/삭제 비효율, 재할당 오버헤드



### Array
: 동일한 데이터 타입의 요소가 순서 있게 나열된 집합  
: 데이터가 메모리 공간에 연속적으로 저장되어 물리적 순서와 논리적 순서가 일치함  
: 배열을 생성할 때 지정한 크기로 메모리 공간이 연속적으로 할당되므로 배열의 크기는 고정됨  
: 배열은 요소와 인덱스로 구성되며 인덱스를 통해 요소에 접근  

**구성**
- 요소 (원소) : 개별 데이터
- 인덱스 (첨자) : 요소의 위치를 나타내는 번호로 일반적으로 0부터 시작하고 일부 언어는 1부터 시작

```
int A[4]

| A[i] | A[i+1] | A[i+2] | A[u] |
--------
  요소

식별자 A는 배열이 시작되는 메모리 주소를 가르키고 
A[2]는 3번째 요소의 메모리 위치를 나타냄 => 메모리 주소 + (2 * 데이터 타입 크기)
```


**저장 방식에 따라**
- 일반 배열 : 데이터가 대부분 채워진 배열
- 희소 배열 : 데이터가 대부분 0인 배열

**인덱스 수에 따라**  
- 1차원 배열 
- 2차원 배열
- 다차원 배열



#### 2차원 배열
: 인덱스가 2개인 배열  
: 2차원 배열도 1차원 배열과 마찬가지로 메모리에 연속적으로 저장됨  
: 메모리 저장 방식에 따라 행 우선 저장 배열과 열 우선 저장 배열로 분류됨  

```
int A[행][열]

int A[2][3] = [[1,2,3], [4,5,6]];
행 우선 저장 => [1,2,3,4,5,6]
열 우선 저장 => [1,4,2,5,3,6]
```


**Matrix**  
: 행렬은 행과 열로 구성된 수학적 개념  
: 행렬의 요소는 행과 열의 인덱스를 통해 위치를 결정하고 행렬 연산을 위해 정의됨  
: 행렬은 2차원 배열 형태로 구현될 수 있으며 행렬 구조의 데이터 저장과 연산이 필요한 경우 사용됨  


**Sparse Matrix**  
: 희소 행렬이란 대부분의 요소 값이 0인 행렬  
: 메모리를 절약하기 위해 다차원 배열을 통해 행렬의 0이 아닌 값만 저장할 수 있음  
: 이런 방법은 메모리 사용은 최소화하지만 요소 접근 방식으로 인해 연산에 대한 비용은 올라갈 수 있음  

저장 방식 | 설명
---|---
좌표 리스트 | 값이 있는 요소의 좌표와 값을 리스트 형태로 저장
압축 행 저장 | 행을 기준으로 각 행의 요소 값과 요소의 열 인덱스 저장
압축 열 저장 | 열을 기준으로 각 열의 요소 값과 요소의 행 인덱스 저장



### Dynamic Array
: 배열의 크기가 동적으로 조절되는 자료구조  
: 내부는 정적 배열로 구현되었으며 연산에 의해 메모리 공간이 부족하면 새로운 배열을 할당함  
: 언어에 따라 Vector나 ArrayList라는 이름으로 구현되어 제공됨  



## Linked List
: 연결 리스트는 요소들이 서로 연결되는 자료구조  
: 논리적 순서는 연속적이지만 물리적인 위치는 무작위로 저장됨  
: 연결 리스트 요소는 데이터와 데이터를 연결하는 링크로 구성되며 포인터를 사용해 연결됨  
: 메모리 크기가 동적으로 조절되고 삽입과 삭제가 효율적이나 특정 요소로 직접 접근이 불가능하고 순차적으로 접근해야 함  

**구현체**
- [단일 연결 리스트](#singly-linked-list)
- [이중 연결 리스트](#doubly-linked-list)
- [원형 연결 리스트](#circular-linked-list)



### Singly Linked List
: 노드가 데이터와 다음 노드를 가르키는 포인터로 구성된 단순한 리스트  
: 다음 노드에 대한 정보만 가지고 있어 한 방향으로만 탐색 가능  
: 구현이 간단하나 특정 노드에 접근하려면 처음부터 순차적으로 탐색해야 하므로 성능이 좋지 않음  

**노드 구성**
- 데이터 필드
- 링크 필드 : 다음 노드를 가르키는 포인터

```
Head => Node => Node => Node

리스트의 첫 번째 노드를 가리키는 포인터를 헤드 포인터라고 하며 이를 통해 리스트의 논리적 연결을 파악함
리스트의 마지막 노드를 테일 노드라고 하며 테일 노드의 링크는 NULL을 가리키며 이를 통해 리스트의 끝을 구분함
```


**구현**
```c
struct Node {
  int data;
  struct Node* link;
};

struct Node* createNode(int data) {
  struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
  newNode->data = data;
  newNode->link = NULL;
  return newNode;
}
```



### Doubly Linked List
: 2개의 링크 필드를 사용해 선행 노드와 후행 노드를 가리켜 양방향 탐색이 가능한 리스트  
: 단일 연결 리스트와 비교해 메모리를 더 사용지만 삽입, 수정, 삭제, 검색 연산이 더 효율적임  
: 링크 필드를 2개 사용하기 때문에 노드를 삭제하거나 수정할 경우 메모리 관리와 링크 관리가 더 복잡함  

**노드 구성**
- 데이터 필드
- 왼쪽 링크 필드 : 이전 노드를 가르키는 포인터
- 오른쪽 링크 필드 : 다음 노드를 가르키는 포인터

```
<= Head => Node <=> Node <=> Node
```


**구현**
```c
struct Node {
  int data;
  struct Node* prev;
  struct Node* next;
};

struct Node* createNode(int data) {
  struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
  newNode->data = data;
  newNode->prev = NULL;
  newNode->next = NULL;
  return newNode;
}
```



### Circular Linked List
: 마지막 노드의 링크 필드가 첫 번째 노드를 가리켜 전체 리스트를 원형으로 연결함  
: 마지막 노드에서 첫 번째 노드로 순환되므로 반복적인 순회가 필요한 경우 사용하기 적합함  
: 순회하는 특성 때문에 잘못된 접근시 무한 루프에 빠질 수 있으므로 주의해야 함  

**종류**  
- 단순 원형 연결 리스트 : 단방향 순회
- 이중 원형 연결 리스트 : 양방향 순회